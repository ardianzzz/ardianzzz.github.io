<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
    font: 10px sans-serif;
    display: inline;
    fill: #fff;
}

.key path {
    display: none;
}

.key line {
    stroke: #000;
    shape-rendering: crispEdges;
}

.key text {
    font-size: 10px;
}

body {
    font: 12px/1.5 system, sans-serif;
}

table {
    border-collapse: collapse;
}

th {
    text-align: left;
    padding: 4px 8px;
}

th:first-of-type,
td:first-of-type {
    padding-left: 0;
}

th:last-of-type,
td:last-of-type {
    padding-right: 0;
}

td {
    padding: 4px 8px;
    border-top: solid 1px #e6e6e6;
}

td:last-of-type {
    text-align: right;
}
</style>

<body>
    <div style="display:table">
        <div style="display: table-cell;vertical-align: top;">
            <div id="table_container" class="csvTable"></div>
        </div>
        <div style="display: table-cell;vertical-align: top;">
            <div id="map"></div>
        </div>
    </div>
    <script src="js/d3.v4.min.js"></script>
    <script src="js/topojson.v1.min.js"></script>
    <script>
    // Set window height + width
    var width = 640,
        height = 640;

    var jsonOutside;

    // Define map projection
    var projection = d3.geo.mercator()
        .scale(1)
        .translate([0, 0]);



    // Define path generator
    var path = d3.geo.path()
        .projection(projection);

    // Create a path generator.

    // Create SVG Element
    var svg = d3.select("#map").append("svg")
        .attr("width", width)
        .attr("height", height);

    // Define scale to sort data values into color buckets
    var color = d3.scale.threshold()
        .domain([5000, 100000, 20000, 40000, 60000, 80000, 100000, 150000, 200000])
        .range(["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]);

    // Legend Stuff

    var y = d3.scale.sqrt()
        .domain([0, 50000])
        .range([0, 325]);

    var yAxis = d3.svg.axis()
        .scale(y)
        .tickValues(color.domain())
        .orient("right");

    // Load CSV
    d3.csv("js/sleman.csv", function(data) {






        // Load TopoJSON
        d3.json("js/sleman.json", function(error, slm) {

            for (var i = 0; i < data.length; i++) {
                var dataTown = data[i].town;
                var dataPop = parseFloat(data[i].population);

                for (var j = 0; j < slm.objects.sleman_town.geometries.length; j++) {
                    var jsonTown = slm.objects.sleman_town.geometries[j].properties.name;

                    if (dataTown == jsonTown) {
                        slm.objects.sleman_town.geometries[j].properties.population = dataPop;
                        break;
                    }

                }
            }

            var desa = topojson.feature(slm, slm.objects.sleman_town);


            // Compute the bounds of a feature of interest, then derive scale & translate.
            var b = path.bounds(desa),
                s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
                t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];


            projection
                .scale(s)
                .translate(t);

            svg.append("path")
                .datum(desa)
                .attr("d", path)
                .style("stroke", "#333")
                .style("stroke-width", "1");


            // var g = svg.append("g")
            //     .attr("class", "key")
            //     .attr("transform", "translate(320, 165)")
            //     .call(yAxis);

            // g.selectAll("rect")
            //     .data(color.range().map(function(d, i) {
            //         return {
            //             y0: i ? y(color.domain()[i - 1]) : y.range()[0],
            //             y1: i < color.domain().length ? y(color.domain()[i]) : y.range()[1],
            //             z: d
            //         };
            //     }))
            //     .enter().append("rect")
            //     .attr("width", 8)
            //     .attr("y", function(d) {
            //         return d.y0;
            //     })
            //     .attr("height", function(d) {
            //         return d.y1 - d.y0;
            //     })
            //     .style("fill", function(d) {
            //         return d.z;
            //     });


            svg.selectAll()
                .data(topojson.feature(slm, slm.objects.sleman_town).features)
                .enter().append("path")
                .attr("d", path)
                .style("stroke", "rgba(255,255,255,.4)")
                .style("stroke-width", "1")
                .style("fill", function(d) {
                    var population = d.properties.population;

                    if (population) {
                        return color(population);
                    } else {
                        return "#ddd";
                    }
                })

            .on("mouseover", function(d) {
                    var xPosition = d3.mouse(this)[0];
                    var yPosition = d3.mouse(this)[1] - 60;

                    svg.append("text")
                        .attr("id", "tooltip")
                        .attr("x", xPosition)
                        .attr("y", yPosition)
                        .attr("text-anchor", "middle")
                        .attr("font-family", "sans-serif")
                        .attr("font-size", "11px")
                        .attr("font-weight", "bold")
                        .attr("fill", "#333")
                        .text(d.properties.name + ' (' + d.properties.population + ')');

                    d3.select(this)
                        .style("fill", "#509e2f");
                })
                .on("mouseout", function(d) {
                    d3.select("#tooltip").remove();

                    d3.select(this)
                        .transition()
                        .duration(250)
                        .style("fill", function(d) {
                            var population = d.properties.population;

                            if (population) {
                                return color(population);
                            } else {
                                return "#ddd";
                            }
                        });
                });



            var columns = ["town", "population"];
            var table = d3.select("#table_container").append("table"),
                thead = table.append("thead"),
                tbody = table.append("tbody");

            // append the header row
            thead.append("tr")
                .selectAll("th")
                .data(columns)
                .enter()
                .append("th")
                .text(function(column) {
                    return column;
                });

            // create a row for each object in the data
            var rows = tbody.selectAll("tr")
                .data(data)
                .enter()
                .append("tr");

            // create a cell in each row for each column
            var cells = rows.selectAll("td")
                .data(function(row) {
                    return columns.map(function(column) {
                        return {
                            column: column,
                            value: row[column]
                        };
                    });
                })
                .enter()
                .append("td")
                .text(function(d) {
                    return d.value;
                });

        });



    });
    </script>
