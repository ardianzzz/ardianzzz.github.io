<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
    font: 10px sans-serif;
    display: inline;
}

.key path {
    display: none;
}

.key line {
    stroke: #000;
    shape-rendering: crispEdges;
}

.key text {
    font-size: 10px;
}
</style>

<body>
    <div class='gallery' id='chart'> </div>
    <script src="js/d3.v4.min.js"></script>
    <script src="js/topojson.v1.min.js"></script>
    <script>
    // Set window height + width
    var width = 640,
        height = 640;

    // Define map projection
    var projection = d3.geoMercator()
        .scale(1)
        .translate([0, 0]);



    // Define path generator
    var path = d3.geoPath()
        .projection(projection);

    // Create a path generator.

    // Create SVG Element
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    // Define scale to sort data values into color buckets
    var color = d3.scaleThreshold()
        .domain([10, 200, 1000, 2000, 5000, 10000, 20000, 40000, 50000])
        .range(["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]);

    // Legend Stuff

    var y = d3.scaleSqrt()
        .domain([0, 50000])
        .range([0, 325]);

    var yAxis = d3.svgAxis()
        .scale(y)
        .tickValues(color.domain())
        .orient("right");

    // Load CSV
    d3.csv("js/sleman.csv", function(data) {

        // Load TopoJSON
        d3.json("js/sleman.json", function(error, slm) {

            for (var i = 0; i < data.length; i++) {
                var dataTown = data[i].town;
                var dataPop = parseFloat(data[i].population);

                for (var j = 0; j < slm.objects.sleman_town.geometries.length; j++) {
                    var jsonTown = slm.objects.sleman_town.geometries[j].properties.name;

                    if (dataTown.toUpperCase() == jsonTown) {
                        slm.objects.sleman_town.geometries[j].properties.population = dataPop;
                        break;
                    }

                }
            }

            var desa = topojson.feature(slm, slm.objects.sleman_town);


            // Compute the bounds of a feature of interest, then derive scale & translate.
            var b = path.bounds(desa),
                s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
                t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];


            projection
                .scale(s)
                .translate(t);

            svg.append("path")
                .datum(desa)
                .attr("d", path)
                .style("stroke", "#333")
                .style("stroke-width", "1");


            var g = svg.append("g")
                .attr("class", "key")
                .attr("transform", "translate(320, 165)")
                .call(yAxis);

            g.selectAll("rect")
                .data(color.range().map(function(d, i) {
                    return {
                        y0: i ? y(color.domain()[i - 1]) : y.range()[0],
                        y1: i < color.domain().length ? y(color.domain()[i]) : y.range()[1],
                        z: d
                    };
                }))
                .enter().append("rect")
                .attr("width", 8)
                .attr("y", function(d) {
                    return d.y0;
                })
                .attr("height", function(d) {
                    return d.y1 - d.y0;
                })
                .style("fill", function(d) {
                    return d.z;
                });


            svg.selectAll(".subunit")
                .data(topojson.feature(slm, slm.objects.sleman_town).features)
                .enter().append("path")
                .attr("d", path)
                .style("fill", function(d) {
                    var population = d.properties.population;

                    if (population) {
                        return color(population);
                    } else {
                        return "#ddd";
                    }
                })

            .on("mouseover", function(d) {
                    var xPosition = d3.mouse(this)[0];
                    var yPosition = d3.mouse(this)[1] - 30;

                    svg.append("text")
                        .attr("id", "tooltip")
                        .attr("x", xPosition)
                        .attr("y", yPosition)
                        .attr("text-anchor", "middle")
                        .attr("font-family", "sans-serif")
                        .attr("font-size", "11px")
                        .attr("font-weight", "bold")
                        .attr("fill", "black")
                        .text(d.properties.name);

                    d3.select(this)
                        .style("fill", "#509e2f");
                })
                .on("mouseout", function(d) {
                    d3.select("#tooltip").remove();

                    d3.select(this)
                        .transition()
                        .duration(250)
                        .style("fill", function(d) {
                            var population = d.properties.population;

                            if (population) {
                                return color(population);
                            } else {
                                return "#ddd";
                            }
                        });
                });

            // svg.append("path")
            //     .datum(topojson.feature(slm, slm.objects.lake))
            //     .attr("d", path)
            //     .style("stroke", "#89b6ef")
            //     .style("stroke-width", "1px")
            //     .style("fill", "#b6d2f5");

        });
    });
    </script>
